workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

default:
  cache:
    key: "$CI_PROJECT_PATH-$CI_COMMIT_REF_SLUG"
    policy: pull-push
    paths:
      - .cache/pip/
      - .ansible/roles
  variables:
    {}
  tags:
    - linux
    - docker
  before_script:
    - python3 --version || true
    - echo "SOC_AUDIT_LOG=$SOC_AUDIT_LOG"
    - mkdir -p .cache/pip .cache/ansible || true
  after_script:
    - echo "Job ${CI_JOB_NAME} finished at $(date -Iseconds)" >> "$SOC_AUDIT_LOG" || true
    - true
stages:
  - lint       # Security & syntax checks
  - test       # Unit tests & validation
  - deploy     # Controlled deployments
  - audit      # SOC compliance logging

image: python:3.11-slim

variables:
  ANSIBLE_FORCE_COLOR: "1"
  SOC_AUDIT_LOG: "$CI_PROJECT_DIR/soc_audit.log"
  OWNERSHIP_OWNER: "ci"
  # Optional container registry config for image build/release demo (kept optional)
  DOCKER_REGISTRY: "$CI_REGISTRY"
  DOCKER_IMAGE: "$CI_REGISTRY_IMAGE/ansible-secure"
  DOCKER_TAG: "$CI_COMMIT_SHORT_SHA"
  APP_DOCKERFILE: "Dockerfile"
  # Ansible defaults (override in CI/CD variables as needed)
  ANSIBLE_INVENTORY: "inventories/dev"
  ANSIBLE_INVENTORY_PROD: "inventories/prod"
  ANSIBLE_PLAYBOOK: "playbooks/deploy.yml"
  ANSIBLE_USER: "ubuntu"
  ANSIBLE_EXTRA_VARS: ""
  ANSIBLE_STDOUT_CALLBACK: "yaml"
  ANSIBLE_HOST_KEY_CHECKING: "False"
  ANSIBLE_RETRY_FILES_ENABLED: "False"
  ANSIBLE_FORCE_COLOR: "True"
  ANSIBLE_FORKS: "20"
  ANSIBLE_TIMEOUT: "30"
  ANSIBLE_GALAXY_CACHE_DIR: ".cache/ansible/galaxy"
  # Optional SOC/ops controls
  ROLLBACK_PLAYBOOK: "playbooks/rollback.yml"
  ROLLBACK_TAG: "rollback"
  SLACK_WEBHOOK: ""

# Core Ansible pipeline with readability
# - Hidden base to reduce duplication across Ansible jobs
.ansible_base:
  image: python:3.11-slim
  before_script:
    - python -m pip install --upgrade pip
    - |
      if [ -f requirements.txt ]; then
        pip install --no-cache-dir -r requirements.txt;
      else
        pip install --no-cache-dir ansible-core==2.16.7 ansible-lint bandit;
      fi
    - |
      mkdir -p .secrets/ssh
      if [ -n "$ANSIBLE_SSH_PRIVATE_KEY" ]; then
        echo "$ANSIBLE_SSH_PRIVATE_KEY" > .secrets/ssh/id_rsa
        chmod 600 .secrets/ssh/id_rsa
      fi
    - |
      if [ -f requirements.yml ]; then
        ansible-galaxy install -r requirements.yml || true;
      fi

# Ansible lint (if playbooks exist)
ansible_lint:
  stage: test
  extends: .ansible_base
  allow_failure: true
  script:
    - |
      if [ -d "playbooks" ]; then
        ansible-lint playbooks
      else
        echo "No playbooks/ directory; skipping ansible-lint"
      fi
  rules:
    - changes:
        - "ansible.cfg"
    - changes:
        - "playbooks/**"
        - "roles/**"
        - "inventories/**"
        - "group_vars/**"
        - "host_vars/**"

bandit_scan:
  stage: lint
  extends: .ansible_base
  script:
    - bandit -r . -f json -o bandit-report.json
  artifacts:
    reports:
      security_dashboard: bandit-report.json
  allow_failure: false

detect_secrets:
  stage: lint
  image: zricethezav/gitleaks:latest
  script:
    - gitleaks detect --no-git -v

# Container image vulnerability scan (optional if image exists)
container_scan:
  stage: lint
  image: aquasec/trivy:latest
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $DOCKER_IMAGE'
  script:
    - trivy image --exit-code 1 --no-progress "$DOCKER_IMAGE:$DOCKER_TAG" || true

# Pre-flight: Ansible check-mode (no changes) for DEV
validate_ansible:
  stage: test
  extends: .ansible_base
  needs: []
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - changes:
        - "playbooks/**"
        - "inventories/**"
        - "group_vars/**"
        - "host_vars/**"
        - "roles/**"
        - "ansible.cfg"
        - "requirements.yml"
  script:
    - |
      set -e
      EXTRA_OPTS=""
      VAULT_CONTENT="${ANSIBLE_VAULT_PASSWORD:-$ANSIBLE_VAULT_PASS}"
      if [ -n "$VAULT_CONTENT" ]; then
        echo "$VAULT_CONTENT" > .secrets/vault.pass
        EXTRA_OPTS="--vault-password-file .secrets/vault.pass"
      fi
      SSH_OPT=""; [ -f .secrets/ssh/id_rsa ] && SSH_OPT="--private-key .secrets/ssh/id_rsa"
      EV_OPTS=""; [ -n "$ANSIBLE_EXTRA_VARS" ] && EV_OPTS="--extra-vars $ANSIBLE_EXTRA_VARS"
      ansible-playbook -i "$ANSIBLE_INVENTORY" "$ANSIBLE_PLAYBOOK" --syntax-check
  artifacts:
    when: always
    expire_in: 2 days
    paths:
      - .secrets/
  interruptible: true
  retry: 1
  timeout: 30m

# Apply: Ansible execution for DEV after check passes
dry_run_dev:
  stage: deploy
  extends: .ansible_base
  needs: ["validate_ansible"]
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  script:
    - |
      set -e
      EXTRA_OPTS=""
      VAULT_CONTENT="${ANSIBLE_VAULT_PASSWORD:-$ANSIBLE_VAULT_PASS}"
      if [ -n "$VAULT_CONTENT" ]; then
        echo "$VAULT_CONTENT" > .secrets/vault.pass
        EXTRA_OPTS="--vault-password-file .secrets/vault.pass"
      fi
      SSH_OPT=""; [ -f .secrets/ssh/id_rsa ] && SSH_OPT="--private-key .secrets/ssh/id_rsa"
      EV_OPTS=""; [ -n "$ANSIBLE_EXTRA_VARS" ] && EV_OPTS="--extra-vars $ANSIBLE_EXTRA_VARS"
      ansible-playbook -i "$ANSIBLE_INVENTORY" "$ANSIBLE_PLAYBOOK" \
        -u "$ANSIBLE_USER" $SSH_OPT $EXTRA_OPTS $EV_OPTS \
        --forks "$ANSIBLE_FORKS" --timeout "$ANSIBLE_TIMEOUT" --check --diff -vv \
        > ansible_dry_run.log 2>&1
  artifacts:
    when: always
    expire_in: 3 days
    paths:
      - .secrets/
      - ansible_dry_run.log
  interruptible: true
  retry: 1
  timeout: 60m

deploy_dev:
  stage: deploy
  extends: .ansible_base
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  needs: ["dry_run_dev"]
  script:
    - |
      set -e
      INV="$ANSIBLE_INVENTORY"
      PB="$ANSIBLE_PLAYBOOK"
      EXTRA_OPTS=""
      VAULT_CONTENT="${ANSIBLE_VAULT_PASSWORD:-$ANSIBLE_VAULT_PASS}"
      if [ -n "$VAULT_CONTENT" ]; then
        echo "$VAULT_CONTENT" > .secrets/vault.pass
        EXTRA_OPTS="--vault-password-file .secrets/vault.pass"
      fi
      SSH_OPT=""; [ -f .secrets/ssh/id_rsa ] && SSH_OPT="--private-key .secrets/ssh/id_rsa"
      ansible-playbook -i "$INV" "$PB" -u "$ANSIBLE_USER" $SSH_OPT $EXTRA_OPTS -vv \
        > ansible_deploy_dev.log 2>&1
  artifacts:
    when: always
    expire_in: 7 days
    paths:
      - ansible_deploy_dev.log
  environment:
    name: dev
    action: deploy
  resource_group: dev-environment
  interruptible: true
  timeout: 45m

deploy_prod:
  stage: deploy
  extends: .ansible_base
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  when: manual
  allow_failure: false
  script:
    - |
      set -e
      INV="$ANSIBLE_INVENTORY_PROD"
      PB="$ANSIBLE_PLAYBOOK"
      EXTRA_OPTS=""
      VAULT_CONTENT="${ANSIBLE_VAULT_PASSWORD:-$ANSIBLE_VAULT_PASS}"
      if [ -n "$VAULT_CONTENT" ]; then
        echo "$VAULT_CONTENT" > .secrets/vault.pass
        EXTRA_OPTS="--vault-password-file .secrets/vault.pass"
      fi
      SSH_OPT=""; [ -f .secrets/ssh/id_rsa ] && SSH_OPT="--private-key .secrets/ssh/id_rsa"
      ansible-playbook -i "$INV" "$PB" -u "${ANSIBLE_USER_PROD:-$ANSIBLE_USER}" $SSH_OPT $EXTRA_OPTS -vv \
        > ansible_deploy_prod.log 2>&1
      echo '{"action":"ansible_deploy","env":"prod","user":"'"$GITLAB_USER_EMAIL"'","pipeline":"'"$CI_PIPELINE_ID"'","commit":"'"$CI_COMMIT_SHA"'","playbook":"'"$PB"'","inventory":"'"$INV"'"}' >> "$SOC_AUDIT_LOG"
  artifacts:
    when: always
    expire_in: 14 days
    paths:
      - ansible_deploy_prod.log
  environment:
    name: production
    action: deploy
    url: "$PROD_URL"
  resource_group: prod-environment
  interruptible: true
  timeout: 90m

# Manual rollback for DEV using either dedicated playbook or rollback tag
rollback_dev:
  stage: deploy
  extends: .ansible_base
  when: manual
  allow_failure: false
  script:
    - |
      set -e
      INV="$ANSIBLE_INVENTORY"
      PB="$ANSIBLE_PLAYBOOK"
      EXTRA_OPTS=""
      VAULT_CONTENT="${ANSIBLE_VAULT_PASSWORD:-$ANSIBLE_VAULT_PASS}"
      if [ -n "$VAULT_CONTENT" ]; then
        echo "$VAULT_CONTENT" > .secrets/vault.pass
        EXTRA_OPTS="--vault-password-file .secrets/vault.pass"
      fi
      SSH_OPT=""; [ -f .secrets/ssh/id_rsa ] && SSH_OPT="--private-key .secrets/ssh/id_rsa"
      if [ -f "$ROLLBACK_PLAYBOOK" ]; then
        ansible-playbook -i "$INV" "$ROLLBACK_PLAYBOOK" -u "$ANSIBLE_USER" $SSH_OPT $EXTRA_OPTS -vv \
          > ansible_rollback_dev.log 2>&1;
      else
        ansible-playbook -i "$INV" "$PB" -u "$ANSIBLE_USER" $SSH_OPT $EXTRA_OPTS --tags "$ROLLBACK_TAG" -vv \
          > ansible_rollback_dev.log 2>&1;
      fi
      echo '{"action":"ansible_rollback","env":"dev","user":"'"$GITLAB_USER_EMAIL"'","pipeline":"'"$CI_PIPELINE_ID"'","commit":"'"$CI_COMMIT_SHA"'"}' >> "$SOC_AUDIT_LOG"
  artifacts:
    when: always
    expire_in: 7 days
    paths:
      - ansible_rollback_dev.log
  environment:
    name: dev
    action: stop

# Manual rollback for PROD (serialized)
rollback_prod:
  stage: deploy
  extends: .ansible_base
  when: manual
  allow_failure: false
  resource_group: prod-environment
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  script:
    - |
      set -e
      INV="$ANSIBLE_INVENTORY_PROD"
      PB="$ANSIBLE_PLAYBOOK"
      EXTRA_OPTS=""
      VAULT_CONTENT="${ANSIBLE_VAULT_PASSWORD:-$ANSIBLE_VAULT_PASS}"
      if [ -n "$VAULT_CONTENT" ]; then
        echo "$VAULT_CONTENT" > .secrets/vault.pass
        EXTRA_OPTS="--vault-password-file .secrets/vault.pass"
      fi
      SSH_OPT=""; [ -f .secrets/ssh/id_rsa ] && SSH_OPT="--private-key .secrets/ssh/id_rsa"
      if [ -f "$ROLLBACK_PLAYBOOK" ]; then
        ansible-playbook -i "$INV" "$ROLLBACK_PLAYBOOK" -u "${ANSIBLE_USER_PROD:-$ANSIBLE_USER}" $SSH_OPT $EXTRA_OPTS -vv \
          > ansible_rollback_prod.log 2>&1;
      else
        ansible-playbook -i "$INV" "$PB" -u "${ANSIBLE_USER_PROD:-$ANSIBLE_USER}" $SSH_OPT $EXTRA_OPTS --tags "$ROLLBACK_TAG" -vv \
          > ansible_rollback_prod.log 2>&1;
      fi
      echo '{"action":"ansible_rollback","env":"prod","user":"'"$GITLAB_USER_EMAIL"'","pipeline":"'"$CI_PIPELINE_ID"'","commit":"'"$CI_COMMIT_SHA"'"}' >> "$SOC_AUDIT_LOG"
  artifacts:
    when: always
    expire_in: 14 days
    paths:
      - ansible_rollback_prod.log
  environment:
    name: production
    action: stop

audit_log:
  stage: audit
  image: alpine:3.19
  script:
    - |
      echo "{\"timestamp\":\"$(date -Iseconds)\",\"user\":\"$GITLAB_USER_EMAIL\",\"action\":\"pipeline_run\",\"pipeline\":\"$CI_PIPELINE_ID\",\"project\":\"$CI_PROJECT_PATH\",\"branch\":\"$CI_COMMIT_BRANCH\",\"commit\":\"$CI_COMMIT_SHA\"}" >> "$SOC_AUDIT_LOG"
  artifacts:
    when: always
    paths:
      - soc_audit.log
    expire_in: 30 days

# Slack notifications (optional)
slack_notify_failure:
  stage: audit
  image: alpine:3.19
  when: on_failure
  script:
    - |
      if [ -n "$SLACK_WEBHOOK" ]; then
        apk add --no-cache curl jq
        payload=$(jq -n --arg text "Pipeline FAILED: $CI_PROJECT_PATH@$CI_COMMIT_REF_NAME ($CI_PIPELINE_URL)" '{text: $text}')
        curl -s -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK" || true
      else
        echo "SLACK_WEBHOOK not set; skipping Slack failure notify";
      fi

slack_notify_prod_deploy:
  stage: audit
  image: alpine:3.19
  needs: ["deploy_prod"]
  when: on_success
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  script:
    - |
      if [ -n "$SLACK_WEBHOOK" ]; then
        apk add --no-cache curl jq
        payload=$(jq -n --arg text "Prod deploy SUCCESS by $GITLAB_USER_EMAIL: $CI_PROJECT_PATH@$CI_COMMIT_SHORT_SHA ($CI_PIPELINE_URL)" '{text: $text}')
        curl -s -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK" || true
      else
        echo "SLACK_WEBHOOK not set; skipping Slack prod notify";
      fi
